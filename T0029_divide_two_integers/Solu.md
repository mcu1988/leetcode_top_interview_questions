# leetcode t29
- 不使用乘除和取余运算，计算两数字的商
- 被除数和除数范围，-2^31 <= dividend, divisor <= 2^31 - 1
- divisor != 0
- eg， 
    - dividend = 10, divisor = 3, return 3
    - 特殊case
         - dividend = -2147483648, divisor = -1, return 2147483647  
         - dividend = -2147483648, divisor = 1, return -2147483648  
         - dividend = -2147483648, divisor = -2, return 1073741824  

# 思路1
- 使用减法代替除法
- int负数最小值比int正数最大值多1，考虑吧数组转为负数处理
- divisor = -2^31时，divisor = 1， return -2^3, divisor = -1， return 2^31 - 1
- 时间复杂度，O(n / m)，空间复杂度O(1)

# 思路2
- 全部使用位运算实现加减乘除
- 位运算实现加法
     - a ^ b是 a + b不考虑每个位置的符号位
     - a & b << 1是a + b的所有位置的符号位
     - 两部分相加直到符号位是0
- 位运算实现减法
     - a -b = a + (-b)
- 位运算实现相反数计算
    - a按位取反再+1就是a的相反数，-a = ~a+ 1
- 位运算实现乘法
    - 与十进制乘法计算方式一样，把第二个乘数按照每一个位置拆分，分别和第一个乘数相乘，再把结果相加
    - 实现
        - a << 1
        - b >> 1
        - 查看b当前位是否是1，是1就把a的当前值累加到结果中
        - 直到b = 0，循环结束
- 加减乘3中运算也适用于负数，不需要做特殊处理，除法需要特殊处理
- 位运算实现除法
    - 把负数全部转化为正数处理
    - 除法可以理解为乘法的逆运算，a = b * x1 + b * x2 + ..., x1, x2就是的整数次方
    - 实现
        - 循环32次，每次把a右移 i 位，如果  a >> i > b, 说明result的i位置的结果是1
        - a = a - b << i
        - 每次循环搞定result的一个位上的数字
        - a = int最小值时，先计算a+1 /b 的商，在计算 余数 / b的商，两部分相加就是最终结果
        - 根据a和b的正负，确定结果是否需要加上负号
- 题目解法
    - int最小值无法转为正数，先处理边界条件
    - 先处理b = int最小值的情况，若a = int最小值，返回1，否则返回0
    - 再处理a = int最小值的情况，
         - 先计算 (a + 1) / b的商
         - 再计算 a / b 的 余数 / b的商
         - 两部分相加
     - 其他情况直接相除
- 时间复杂度，O(32)，空间复杂度O(1)