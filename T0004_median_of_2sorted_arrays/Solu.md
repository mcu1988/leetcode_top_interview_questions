# leetcode t4
- 2个有序数组的中位数
- 数组类型为整数，数组有序, 数组长度可能不一致，数组可以为空
- 数组总长度是奇数，返回中位数，偶数返回上中位数和下中位数的平均数
- eg， 
    - nums1 = [], nums2 = [1], return 1
    - nums1 = [1,3], nums2 = [2]，return 2
    - nums1 = [1,2], nums2 = [3,4], return 2.5
        
# 思路1
- 找到数组的上中位数，对于总和为奇数的情况，直接返回上中位数，偶数的情况，返回上中位数和下一个元素的平均值
- 使用index1, index2分别遍历2个数组，类似归并排序的merge过程，对2个数组合并排序，找到上中位数
- 中位数的位置分为4中情况
- 中位数分4种情况
    - 1 数组1和数组2遍历都没越界时，找到了中位数
    - 2 数组1和数组2有一个越界了，中位数刚好在越界数组的边界上, eg, num1=[1,2],num2=[3,4], 中位数是num1[1]+nums2[0]
    - 3 数组1和数组2有一个越界，中位数在剩下的一个数组上
    - 不可能2个数组都越界，因为寻找的是中位数，不可能同时让2个数组越界
- 时间复杂度O(m+n), 空间复杂度O(1)

# 思路2
- 二分数组
- nums1长度为m, nums2长度为n
- 较短的长度是short, 长的长度是long
- 以short=10, long=17为例
- 实现2个函数
    - 函数f返回2数组特定范围中第k小的数,k是从1开始计数，数组可以不等长，f(int[] nums1, int[] nums2, int k)
    - 函数g返回2个等长数组特定范围的中位数，g(int[] nums1, int l1, int r1, int[] nums2, int l2, int r2)
- f函数实现
    - 如果k<=short, 把2个数组的前k个都拿出来比较，返回上中位数
        - eg, k=2,分别取两个数组的强2个元素，调用g函数，返回上中位数2的值
    - 如果short < k <= long, eg k = 15
        - 可能的范围是短数组 \[0 ~ 9\](short长度) + 长数组[4 ~ 14] （short+1长度）
        - 长度不等，不能调用g函数
        - 手动排除长数组4位置上的值
            - 如果该值>=短数组的最后位置9的值，直接返回该值作为最终答案
            - 否则，排除了长数组4位置上的值，长度再次相等，可能的范围变成短数组\[0~9\], 长数组[5 ~ 14]
                - 排除了长数组的前5个元素，调用g函数返回上中位数10，最终得到k=15位置的值
    - 如果 long < k <= short+long, eg k=23
        - 可能的范围是短数组[5~9]，长数组[12~16]
        - 长度一致，不能直接调用g函数，因为短数组排除了[0~4], 长数组排除了[0~11], g函数返回上中位数5的值，得到第22小的值，不是第23小的值
        - 手动排除短数组5位置和长数组12位置的值
            - 短数组5位置 >= 长数组最后一个位置，直接返回
            - 长数组12位置 >= 短数组最后一个位置，直接返回
            - 否则，可能的范围是短数组[6~9]，长数组[13~16]，短数组排除前6个元素，长数组排除了前13个元素，调用g函数返回上中位数4的值，刚好是第23小的数字
- g函数实现
    - 输入是2个等长数组
    - 分别取上中位数，如果相等，直接返回
    - 如果nums1上中位数小于nums2上中位数
        - 如果数组长度是偶数,
            - 可能的范围是nums1[upMid+1, r], nums2[0, upMid]，继续递归调用g函数
            -  eg, nums1,nums2长度都是4，返回上中位数4的值， 可能的范围是nums1[2, 3], nums2[0, 1]
        - 如果数组长度是奇数
            - 可能的范围是nums1[upMid, r], nums2[0, upMid-1]，继续递归调用g函数
            - eg, nums1,nums2长度都是5，返回上中位数5的值， 可能的范围是nums1[2, 4], nums2[0, 1]
            - 长度不等，需要手动排除nums1里2位置的值
                - 如果该值 >= nums2里1位置的值，直接返回
                - 否则，可能的范围是nums1[3, 4], nums2[0, 1]，调用g函数
    - 如果nums1上中位数大于nums2上中位数，同理
    - 递归终止条件，当2个数组长度为1时，直接比较并返回
- 如何调用f函数
    - 如果m+n是奇数，调用f返回上中位数
    - 如果m+n是奇数，调用2次f，分别返回上中位数和下中位数，求和返回平均值
- 两个数组有一个为空时，单独判断，直接返回名外一个数组的中位数
- 时间复杂度O(log(min(m,n))), 空间复杂度O(1)