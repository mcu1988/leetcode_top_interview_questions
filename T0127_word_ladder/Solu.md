# leetcode t127
- 字典梯子
- 给定初始单词beginWord和结束单词endWord以及候选单词表，初始单词每次改变一个位置的值，  
改变后的值需要在单词表内，循坏推进，直到到达endWord结束，返回单词链的长度
- beginWord -> s1 -> s2 -> ... -> sk, 单词链的长度包含beginWord
- endWord必须在单词表内
- 单词全部由小写字母组成
- eg
    - beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]， return 5

# 思路1
- 方法1
- 找到wordlist中所有词的全排列，查看每一种排列是否有效，无效返回0，有效返回长度
- 递归函数，生成全排列，并检查是否有效，f(List<String> wordList, int index, String lastWord, String endWord)
    - 深度优先遍历，生成wordList的全排列，每生成一个词，判断与前一个词之间是否只哟偶1个字符的差别
    - index: 全排列当前来到的位置
    - lastWord: 上一个全排列生成的单词
    - endWord: 目标单词
    - 递归的最大深度为N，因为wordList的词值值出现1次
    - 如果相邻单词差异不是1个字符，提前返回
- 时间复杂度O(N! * k), N是wordlist的长度，k是单词的长度， 空间复杂度O(N)
- java实现超时

# 方法2
- 以beginWord为根节点，建立多叉树，层序遍历多叉树，当某一层第一次出现endWord时，返回层数，就是答案
- 使用set记录已经加入到队列中的单词，因为一个单词只能出现在队列中一次，因此，队列中最多有N个单词
- 先生成每个单词的邻接词
    - 依次改变每个位置上的值，把值换成'a'~'z'，查看新生成的词是否在单词表内
- 时间复杂度O(N*K^2), N是wordlist的长度，k是单词的长度， 空间复杂度O(N^2)
- java实现耗时105ms

# 方法3
- 对方法2进行改进，从开始节点和结束节点同时寄到哪里多叉树，每次让节点少的层偶先遍历
- 当头和尾的层节点有交集时，说返回层数
- 使用set记录已经遍历的节点，每个节点只能出现1次
- 初始不简历所有单词的邻接词，在遍历的过程中建立
- 时间复杂度最大为O(N*K^2), N是wordlist的长度，k是单词的长度， 空间复杂度O(N)
- java实现耗时13ms，主要是在遍历过程中计算需要用到单词的邻接单词，减少了无效计算，  
同时，头和尾同时遍历也能减少耗时