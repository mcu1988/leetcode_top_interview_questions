# leetcode t4
- 字符串数组的最长回文子串
- eg， 
    - s = "babad", return "bab"
    - s = "a", return "a"
        
# 思路1
- 依次遍历数组的每个元素，把它当做回文中心，从回文中心往两边扩展，记录最长子串，不断更新
- 回文字符串长度为奇数和偶数
    - 回文字符串是奇数，eg, aba, 以b为中心往两边扩展
    - 回文字符串是偶数，eg, aa, 回文中心是虚轴，不是某个特定的字符
- 解决办法
    - 将原始字符串间隔插入某个字符，如"#", 此时，字符串数量变为奇数
        - eg, "aa"添加"#"后变成"#a#a#", 并且原始字符和原始字符对称，"#"和"#"对称，不会出现"#"和原始字符对比的情况
  - 时间复杂度O(n^2), 空间复杂度O(1)

# 思路2
- Manacher算法
- 几个概念
    - 回文中心c, 回文字符串中心点位置
    - 回文半径R：回文中心点到回文右边界的距离
    - 回文右边界r: 回文字符串最右字符串的位置
- 为了处理偶数回文，把原始字符串插空加入特殊字符串"#"
- 整体思路：遍历字符串，不断更新最右的回文右边界和回文半径，当遍历到新的位置index的字符时，考虑以index为中心的回文字符串，分4种情况        
    - 情况1: index在r外，从index往左右两边扩展，确定半径
    - 情况2: index在r内，l' > l(当前点c的回文左边界)， 那么index的回文半径是R'
    - 情况3: index在r内，l' = l，那么index的回文半径最小是R'，继续判断r+1位置和l-1位置的值是否相等
    - 情况4: index在r内，l' < l，那么index的回文半径是l-index'
- 时间复杂度O(n), 空间复杂度O(n)
